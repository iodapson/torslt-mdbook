<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Iterator - Tour of Rust&#x27;s Standard Library Traits (in mdbook!)</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">Tour of Rust's Standard Library Traits</li><li class="chapter-item "><a href="../intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item "><a href="../chapter-1/trait-basics.html"><strong aria-hidden="true">2.</strong> Trait Basics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter-1/trait-items.html"><strong aria-hidden="true">2.1.</strong> Trait Items</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter-1/self.html"><strong aria-hidden="true">2.1.1.</strong> Self</a></li><li class="chapter-item "><a href="../chapter-1/functions.html"><strong aria-hidden="true">2.1.2.</strong> Functions</a></li><li class="chapter-item "><a href="../chapter-1/methods.html"><strong aria-hidden="true">2.1.3.</strong> Methods</a></li><li class="chapter-item "><a href="../chapter-1/associated-types.html"><strong aria-hidden="true">2.1.4.</strong> Associated Types</a></li><li class="chapter-item "><a href="../chapter-1/generic-parameters.html"><strong aria-hidden="true">2.1.5.</strong> Generic Parameters</a></li><li class="chapter-item "><a href="../chapter-1/generic-types-vs-associated-types.html"><strong aria-hidden="true">2.1.6.</strong> Generic Types vs Associated Types</a></li></ol></li><li class="chapter-item "><a href="../chapter-1/scope.html"><strong aria-hidden="true">2.2.</strong> Scope</a></li><li class="chapter-item "><a href="../chapter-1/derive-macros.html"><strong aria-hidden="true">2.3.</strong> Derive Macros</a></li><li class="chapter-item "><a href="../chapter-1/default-impls.html"><strong aria-hidden="true">2.4.</strong> Default Impls</a></li><li class="chapter-item "><a href="../chapter-1/generic-blanket-impls.html"><strong aria-hidden="true">2.5.</strong> Generic Blanket Impls</a></li><li class="chapter-item "><a href="../chapter-1/subtraits--supertraits.html"><strong aria-hidden="true">2.6.</strong> Subtraits & Supertraits</a></li><li class="chapter-item "><a href="../chapter-1/trait-objects.html"><strong aria-hidden="true">2.7.</strong> Trait Objects</a></li><li class="chapter-item "><a href="../chapter-1/marker-traits.html"><strong aria-hidden="true">2.8.</strong> Marker Traits</a></li><li class="chapter-item "><a href="../chapter-1/auto-traits.html"><strong aria-hidden="true">2.9.</strong> Auto Traits</a></li><li class="chapter-item "><a href="../chapter-1/unsafe-traits.html"><strong aria-hidden="true">2.10.</strong> Unsafe Traits</a></li></ol></li><li class="chapter-item "><a href="../chapter-2/auto-traits-1.html"><strong aria-hidden="true">3.</strong> Auto Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter-2/send--sync.html"><strong aria-hidden="true">3.1.</strong> Send & Sync</a></li><li class="chapter-item "><a href="../chapter-2/sized.html"><strong aria-hidden="true">3.2.</strong> Sized</a></li></ol></li><li class="chapter-item "><a href="../chapter-3/general-traits.html"><strong aria-hidden="true">4.</strong> General Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter-3/default.html"><strong aria-hidden="true">4.1.</strong> Default</a></li><li class="chapter-item "><a href="../chapter-3/clone.html"><strong aria-hidden="true">4.2.</strong> Clone</a></li><li class="chapter-item "><a href="../chapter-3/copy.html"><strong aria-hidden="true">4.3.</strong> Copy</a></li><li class="chapter-item "><a href="../chapter-3/any.html"><strong aria-hidden="true">4.4.</strong> Any</a></li></ol></li><li class="chapter-item "><a href="../chapter-4/formatting-traits.html"><strong aria-hidden="true">5.</strong> Formatting Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter-4/display--tostring.html"><strong aria-hidden="true">5.1.</strong> Display & ToString</a></li><li class="chapter-item "><a href="../chapter-4/debug.html"><strong aria-hidden="true">5.2.</strong> Debug</a></li></ol></li><li class="chapter-item "><a href="../chapter-5/operator-traits.html"><strong aria-hidden="true">6.</strong> Operator Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter-5/comparison-traits.html"><strong aria-hidden="true">6.1.</strong> Comparison Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter-5/partialeq--eq.html"><strong aria-hidden="true">6.1.1.</strong> PartialEq & Eq</a></li><li class="chapter-item "><a href="../chapter-5/hash.html"><strong aria-hidden="true">6.1.2.</strong> Hash</a></li><li class="chapter-item "><a href="../chapter-5/partialord--ord.html"><strong aria-hidden="true">6.1.3.</strong> PartialOrd & Ord</a></li></ol></li><li class="chapter-item "><a href="../chapter-5/arithmetic-traits.html"><strong aria-hidden="true">6.2.</strong> Arithmetic Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter-5/add--addassign.html"><strong aria-hidden="true">6.2.1.</strong> Add & AddAssign</a></li></ol></li><li class="chapter-item "><a href="../chapter-5/closure-traits.html"><strong aria-hidden="true">6.3.</strong> Closure Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter-5/fnonce-fnmut--fn.html"><strong aria-hidden="true">6.3.1.</strong> FnOnce, FnMut, & Fn</a></li></ol></li><li class="chapter-item "><a href="../chapter-5/other-traits.html"><strong aria-hidden="true">6.4.</strong> Other Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter-5/deref--derefmut.html"><strong aria-hidden="true">6.4.1.</strong> Deref & DerefMut</a></li><li class="chapter-item "><a href="../chapter-5/index--indexmut.html"><strong aria-hidden="true">6.4.2.</strong> Index & IndexMut</a></li><li class="chapter-item "><a href="../chapter-5/drop.html"><strong aria-hidden="true">6.4.3.</strong> Drop</a></li></ol></li></ol></li><li class="chapter-item "><a href="../chapter-6/from--into.html"><strong aria-hidden="true">7.</strong> Conversion Traits</a></li><li class="chapter-item "><a href="../chapter-7/error.html"><strong aria-hidden="true">8.</strong> Error Handling</a></li><li class="chapter-item "><a href="../chapter-8/conversion-traits-continued.html"><strong aria-hidden="true">9.</strong> Conversion Traits Continued</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter-8/tryfrom--tryinto.html"><strong aria-hidden="true">9.1.</strong> TryFrom & TryInto</a></li><li class="chapter-item "><a href="../chapter-8/fromstr.html"><strong aria-hidden="true">9.2.</strong> FromStr</a></li><li class="chapter-item "><a href="../chapter-8/asref--asmut.html"><strong aria-hidden="true">9.3.</strong> AsRef & AsMut</a></li><li class="chapter-item "><a href="../chapter-8/borrow--borrowmut.html"><strong aria-hidden="true">9.4.</strong> Borrow & BorrowMut</a></li><li class="chapter-item "><a href="../chapter-8/toowned.html"><strong aria-hidden="true">9.5.</strong> ToOwned</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter-9/iteration-traits.html"><strong aria-hidden="true">10.</strong> Iteration Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter-9/iterator.html" class="active"><strong aria-hidden="true">10.1.</strong> Iterator</a></li><li class="chapter-item "><a href="../chapter-9/intoiterator.html"><strong aria-hidden="true">10.2.</strong> IntoIterator</a></li><li class="chapter-item "><a href="../chapter-9/fromiterator.html"><strong aria-hidden="true">10.3.</strong> FromIterator</a></li></ol></li><li class="chapter-item "><a href="../chapter-10/read--write.html"><strong aria-hidden="true">11.</strong> I/O Traits</a></li><li class="chapter-item "><a href="../chapter-11/conclusion.html"><strong aria-hidden="true">12.</strong> Conclusion</a></li><li class="chapter-item "><a href="../discuss.html"><strong aria-hidden="true">13.</strong> Discuss</a></li><li class="chapter-item "><a href="../notifications.html"><strong aria-hidden="true">14.</strong> Notifications</a></li><li class="chapter-item "><a href="../further-reading.html"><strong aria-hidden="true">15.</strong> Further Reading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tour of Rust&#x27;s Standard Library Traits (in mdbook!)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h3 id="iterator"><a class="header" href="#iterator">Iterator</a></h3>
<p>Prerequisites</p>
<ul>
<li><a href="../chapter-1/self.html">Self</a></li>
<li><a href="../chapter-1/methods.html">Methods</a></li>
<li><a href="../chapter-1/associated-types.html">Associated Types</a></li>
<li><a href="../chapter-1/default-impls.html">Default Impls</a></li>
</ul>
<pre><code class="language-rust">trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    // provided default impls
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
    fn count(self) -&gt; usize;
    fn last(self) -&gt; Option&lt;Self::Item&gt;;
    fn advance_by(&amp;mut self, n: usize) -&gt; Result&lt;(), usize&gt;;
    fn nth(&amp;mut self, n: usize) -&gt; Option&lt;Self::Item&gt;;
    fn step_by(self, step: usize) -&gt; StepBy&lt;Self&gt;;
    fn chain&lt;U&gt;(
        self,
        other: U
    ) -&gt; Chain&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;
    where
        U: IntoIterator&lt;Item = Self::Item&gt;;
    fn zip&lt;U&gt;(self, other: U) -&gt; Zip&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;
    where
        U: IntoIterator;
    fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
    where
        F: FnMut(Self::Item) -&gt; B;
    fn for_each&lt;F&gt;(self, f: F)
    where
        F: FnMut(Self::Item);
    fn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool;
    fn filter_map&lt;B, F&gt;(self, f: F) -&gt; FilterMap&lt;Self, F&gt;
    where
        F: FnMut(Self::Item) -&gt; Option&lt;B&gt;;
    fn enumerate(self) -&gt; Enumerate&lt;Self&gt;;
    fn peekable(self) -&gt; Peekable&lt;Self&gt;;
    fn skip_while&lt;P&gt;(self, predicate: P) -&gt; SkipWhile&lt;Self, P&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool;
    fn take_while&lt;P&gt;(self, predicate: P) -&gt; TakeWhile&lt;Self, P&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool;
    fn map_while&lt;B, P&gt;(self, predicate: P) -&gt; MapWhile&lt;Self, P&gt;
    where
        P: FnMut(Self::Item) -&gt; Option&lt;B&gt;;
    fn skip(self, n: usize) -&gt; Skip&lt;Self&gt;;
    fn take(self, n: usize) -&gt; Take&lt;Self&gt;;
    fn scan&lt;St, B, F&gt;(self, initial_state: St, f: F) -&gt; Scan&lt;Self, St, F&gt;
    where
        F: FnMut(&amp;mut St, Self::Item) -&gt; Option&lt;B&gt;;
    fn flat_map&lt;U, F&gt;(self, f: F) -&gt; FlatMap&lt;Self, U, F&gt;
    where
        F: FnMut(Self::Item) -&gt; U,
        U: IntoIterator;
    fn flatten(self) -&gt; Flatten&lt;Self&gt;
    where
        Self::Item: IntoIterator;
    fn fuse(self) -&gt; Fuse&lt;Self&gt;;
    fn inspect&lt;F&gt;(self, f: F) -&gt; Inspect&lt;Self, F&gt;
    where
        F: FnMut(&amp;Self::Item);
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self;
    fn collect&lt;B&gt;(self) -&gt; B
    where
        B: FromIterator&lt;Self::Item&gt;;
    fn partition&lt;B, F&gt;(self, f: F) -&gt; (B, B)
    where
        F: FnMut(&amp;Self::Item) -&gt; bool,
        B: Default + Extend&lt;Self::Item&gt;;
    fn partition_in_place&lt;'a, T, P&gt;(self, predicate: P) -&gt; usize
    where
        Self: DoubleEndedIterator&lt;Item = &amp;'a mut T&gt;,
        T: 'a,
        P: FnMut(&amp;T) -&gt; bool;
    fn is_partitioned&lt;P&gt;(self, predicate: P) -&gt; bool
    where
        P: FnMut(Self::Item) -&gt; bool;
    fn try_fold&lt;B, F, R&gt;(&amp;mut self, init: B, f: F) -&gt; R
    where
        F: FnMut(B, Self::Item) -&gt; R,
        R: Try&lt;Ok = B&gt;;
    fn try_for_each&lt;F, R&gt;(&amp;mut self, f: F) -&gt; R
    where
        F: FnMut(Self::Item) -&gt; R,
        R: Try&lt;Ok = ()&gt;;
    fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; B
    where
        F: FnMut(B, Self::Item) -&gt; B;
    fn fold_first&lt;F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(Self::Item, Self::Item) -&gt; Self::Item;
    fn all&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
    where
        F: FnMut(Self::Item) -&gt; bool;
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
    where
        F: FnMut(Self::Item) -&gt; bool;
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool;
    fn find_map&lt;B, F&gt;(&amp;mut self, f: F) -&gt; Option&lt;B&gt;
    where
        F: FnMut(Self::Item) -&gt; Option&lt;B&gt;;
    fn try_find&lt;F, R&gt;(
        &amp;mut self,
        f: F
    ) -&gt; Result&lt;Option&lt;Self::Item&gt;, &lt;R as Try&gt;::Error&gt;
    where
        F: FnMut(&amp;Self::Item) -&gt; R,
        R: Try&lt;Ok = bool&gt;;
    fn position&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt;
    where
        P: FnMut(Self::Item) -&gt; bool;
    fn rposition&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt;
    where
        Self: ExactSizeIterator + DoubleEndedIterator,
        P: FnMut(Self::Item) -&gt; bool;
    fn max(self) -&gt; Option&lt;Self::Item&gt;
    where
        Self::Item: Ord;
    fn min(self) -&gt; Option&lt;Self::Item&gt;
    where
        Self::Item: Ord;
    fn max_by_key&lt;B, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(&amp;Self::Item) -&gt; B,
        B: Ord;
    fn max_by&lt;F&gt;(self, compare: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Ordering;
    fn min_by_key&lt;B, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(&amp;Self::Item) -&gt; B,
        B: Ord;
    fn min_by&lt;F&gt;(self, compare: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Ordering;
    fn rev(self) -&gt; Rev&lt;Self&gt;
    where
        Self: DoubleEndedIterator;
    fn unzip&lt;A, B, FromA, FromB&gt;(self) -&gt; (FromA, FromB)
    where
        Self: Iterator&lt;Item = (A, B)&gt;,
        FromA: Default + Extend&lt;A&gt;,
        FromB: Default + Extend&lt;B&gt;;
    fn copied&lt;'a, T&gt;(self) -&gt; Copied&lt;Self&gt;
    where
        Self: Iterator&lt;Item = &amp;'a T&gt;,
        T: 'a + Copy;
    fn cloned&lt;'a, T&gt;(self) -&gt; Cloned&lt;Self&gt;
    where
        Self: Iterator&lt;Item = &amp;'a T&gt;,
        T: 'a + Clone;
    fn cycle(self) -&gt; Cycle&lt;Self&gt;
    where
        Self: Clone;
    fn sum&lt;S&gt;(self) -&gt; S
    where
        S: Sum&lt;Self::Item&gt;;
    fn product&lt;P&gt;(self) -&gt; P
    where
        P: Product&lt;Self::Item&gt;;
    fn cmp&lt;I&gt;(self, other: I) -&gt; Ordering
    where
        I: IntoIterator&lt;Item = Self::Item&gt;,
        Self::Item: Ord;
    fn cmp_by&lt;I, F&gt;(self, other: I, cmp: F) -&gt; Ordering
    where
        F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; Ordering,
        I: IntoIterator;
    fn partial_cmp&lt;I&gt;(self, other: I) -&gt; Option&lt;Ordering&gt;
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn partial_cmp_by&lt;I, F&gt;(
        self,
        other: I,
        partial_cmp: F
    ) -&gt; Option&lt;Ordering&gt;
    where
        F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; Option&lt;Ordering&gt;,
        I: IntoIterator;
    fn eq&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialEq&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn eq_by&lt;I, F&gt;(self, other: I, eq: F) -&gt; bool
    where
        F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; bool,
        I: IntoIterator;
    fn ne&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialEq&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn lt&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn le&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn gt&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn ge&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn is_sorted(self) -&gt; bool
    where
        Self::Item: PartialOrd&lt;Self::Item&gt;;
    fn is_sorted_by&lt;F&gt;(self, compare: F) -&gt; bool
    where
        F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Option&lt;Ordering&gt;;
    fn is_sorted_by_key&lt;F, K&gt;(self, f: F) -&gt; bool
    where
        F: FnMut(Self::Item) -&gt; K,
        K: PartialOrd&lt;K&gt;;
}
</code></pre>
<p><code>Iterator&lt;Item = T&gt;</code> types can be iterated and will produce <code>T</code> types. There's no <code>IteratorMut</code> trait. Each <code>Iterator</code> impl can specify whether it returns immutable references, mutable references, or owned values via the <code>Item</code> associated type.</p>
<div class="table-wrapper"><table><thead><tr><th><code>Vec&lt;T&gt;</code> method</th><th>Returns</th></tr></thead><tbody>
<tr><td><code>.iter()</code></td><td><code>Iterator&lt;Item = &amp;T&gt;</code></td></tr>
<tr><td><code>.iter_mut()</code></td><td><code>Iterator&lt;Item = &amp;mut T&gt;</code></td></tr>
<tr><td><code>.into_iter()</code></td><td><code>Iterator&lt;Item = T&gt;</code></td></tr>
</tbody></table>
</div>
<p>Something that is not immediately obvious to beginner Rustaceans but that intermediate Rustaceans take for granted is that most types are not their own iterators. If a type is iterable we almost always impl some custom iterator type which iterates over it rather than trying to make it iterate over itself:</p>
<pre><code class="language-rust">struct MyType {
    items: Vec&lt;String&gt;
}
impl MyType {
    fn iter(&amp;self) -&gt; impl Iterator&lt;Item = &amp;String&gt; {
        MyTypeIterator {
            index: 0,
            items: &amp;self.items
        }
    }
}
struct MyTypeIterator&lt;'a&gt; {
    index: usize,
    items: &amp;'a Vec&lt;String&gt;
}
impl&lt;'a&gt; Iterator for MyTypeIterator&lt;'a&gt; {
    type Item = &amp;'a String;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.index &gt;= self.items.len() {
            None
        } else {
            let item = &amp;self.items[self.index];
            self.index += 1;
            Some(item)
        }
    }
}
</code></pre>
<p>For the sake of teaching the above example shows how to impl an <code>Iterator</code> from scratch but the idiomatic solution in this situation would be to just defer to <code>Vec</code>'s <code>iter</code> method:</p>
<pre><code class="language-rust">struct MyType {
    items: Vec&lt;String&gt;
}
impl MyType {
    fn iter(&amp;self) -&gt; impl Iterator&lt;Item = &amp;String&gt; {
        self.items.iter()
    }
}
</code></pre>
<p>Also this is a good generic blanket impl to be aware of:</p>
<pre><code class="language-rust">impl&lt;I: Iterator + ?Sized&gt; Iterator for &amp;mut I;
</code></pre>
<p>It says that any mutable reference to an iterator is also an iterator. This is useful to know because it allows us to use iterator methods with <code>self</code> receivers as if they had <code>&amp;mut self</code> receivers.
As an example, imagine we have a function which processes an iterator of more than three items, but the first step of the function is to take out the first three items of the iterator and process them separately before iterating over the remaining items, here's how a beginner may attempt to write this function:</p>
<pre><code class="language-rust">fn example&lt;I: Iterator&lt;Item = i32&gt;&gt;(mut iter: I) {
    let first3: Vec&lt;i32&gt; = iter.take(3).collect();
    for item in iter { // ❌ iter consumed in line above
        // process remaining items
    }
}
</code></pre>
<p>Well that's annoying. The <code>take</code> method has a <code>self</code> receiver so it seems like we cannot call it without consuming the whole iterator! Here's what a naive refactor of the above code might look like:</p>
<pre><code class="language-rust">fn example&lt;I: Iterator&lt;Item = i32&gt;&gt;(mut iter: I) {
    let first3: Vec&lt;i32&gt; = vec![
        iter.next().unwrap(),
        iter.next().unwrap(),
        iter.next().unwrap(),
    ];
    for item in iter { // ✅
        // process remaining items
    }
}
</code></pre>
<p>Which is okay. However, the idiomatic refactor is actually:</p>
<pre><code class="language-rust">fn example&lt;I: Iterator&lt;Item = i32&gt;&gt;(mut iter: I) {
    let first3: Vec&lt;i32&gt; = iter.by_ref().take(3).collect();
    for item in iter { // ✅
        // process remaining items
    }
}
</code></pre>
<p>Not very easy to discover. But anyway, now we know.</p>
<p>Also, there are no rules or conventions on what can or cannot be an iterator. If the type impls <code>Iterator</code> then it's an iterator. Some creative examples from the standard library:</p>
<pre><code class="language-rust">use std::sync::mpsc::channel;
use std::thread;
fn paths_can_be_iterated(path: &amp;Path) {
    for part in path {
        // iterate over parts of a path
    }
}
fn receivers_can_be_iterated() {
    let (send, recv) = channel();
    thread::spawn(move || {
        send.send(1).unwrap();
        send.send(2).unwrap();
        send.send(3).unwrap();
    });
    for received in recv {
        // iterate over received values
    }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter-9/iteration-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../chapter-9/intoiterator.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter-9/iteration-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../chapter-9/intoiterator.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
